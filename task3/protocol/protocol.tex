\documentclass[a4paper,10pt]{article}

\usepackage[usenames,dvipsnames]{color}
\usepackage{comment}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{hyperref}

\definecolor{OliveGreen}{cmyk}{0.64,0,0.95,0.40}
\definecolor{Gray}{gray}{0.5}

\lstset{
    language=C,
    basicstyle=\ttfamily,
    keywordstyle=\color{OliveGreen},
    commentstyle=\color{Gray},
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    showspaces=false,
    showtabs=false,
    numbers=left,
}

\title{VU Software Security \\
       SS 2013 \\
       Task 3}
\author{Jakob Gruber}

\begin{document}

\maketitle

\section{Specification}

When you try to run the binary, you'll immediately see that is not doing much,
because it is controlled by some kind of trigger condition.

This assignment consists in two parts:

Analyze the binary and reveal the trigger that controls the execution of the
program.  Reverse engineer the check, set the right condition and find the
secret message.

Recommended tools:

Debugger, Hexeditor, ...

Please upload a PDF with your report (you do not have to upload the modified
binary)! 

\section{Protocol}

\begin{comment}
step through with GDB,
build control flow graph

400ddf: ptrace control. first, step past with 'set $rax = 0', then substitute
JGE opcode 08 DF with NOP; JMP codes 90 E9 for an unconditional jump.

next bad jump could be at 4010e9: first try is to turn around the conditional (JNE instead of JE)

annotated disassmbly (objdump -D)

0x402b00 (in .bss) is obviously important. there's only one spot that sets it:
  400f1b:	48 89 04 25 00 2b 40 	mov    %rax,0x402b00


again, JE->JNE at 401102

annotating around the SHA1() call -> SHA1() result is used as the key to
the decrypt calls, and *0x4027d0 is hashed. that in turn is set by a combination
of gettimeofday() and some bit masking (only upper 2 bytes are from gettimeofday).
hooked into gettimeofday() calls and wrote a small exploit script to test all combinations:

$ groovy Exploit/src/Exploit.groovy
time: af6a0000: This is not the secret you are looking for!
To dig deeper you have!

-> the key is 0xaf60c0de

set the key statically in our hook.

http://strace.git.sourceforge.net/git/gitweb.cgi?p=strace/strace;a=blob;f=linux/x86_64/syscallent.h;h=8e3a2007ad7bda8fbc7318fd081c6fff3ed2a369;hb=HEAD
http://stackoverflow.com/questions/2535989/what-are-the-calling-conventions-for-unix-linux-system-calls-on-x86-64

hooking into EVP_DecryptUpdate, we receive:
POST EVP_DecryptUpdate(717eaaf0, 7bc000: �n
The secret is: "The truth is out there!"
This is not the secret you are looking for!
To dig deeper you have!
H1�H1�H1�H��H��H�5����H��DH1�H��<H1�, 160, 402800, a0) = 0x7f6900000001

f0 {
  ...
  x0 = ptrace()
  if x0 < 0
    print && exit
  return
}

f1 {
  ...
  f0()
  return
}

f2 {
  ...
  while (x1 != x2) 	// 0x401214
    f1()		// fptr
    x1++
    goto 0x401200	// some magic going on here with function pointers
  }
  return to __libc_start_main()
}

f3 {
  // some arithmetic going on
}

f4() { // 0x400c30
  ...
  SHA1()
  ..
  EVP_.....()
  ...
}

f5() { // 0x404000
  
}

main { // 0x4010d0
  x0 = f3()
  if (x == 0)			// needs to be != 0 at least at first!
    goto l1

  f4()
  
  rax = *0x402b00
  if *rax == 0x540a6eeb
    goto l2
  
  memcpy()
  
  for () { //26 times
    // calc something
  }

  printf(you just fucked with the wrong bin)

  ret

l1:	// 40119e
  printf(msg)
  return

l2: 	// 0x401185
  f5()
}

__libc_start_main() {
  f2()
  main();
}

\end{comment}


\end{document}
